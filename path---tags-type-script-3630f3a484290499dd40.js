webpackJsonp([33543605589326],{595:function(e,t){e.exports={data:{site:{siteMetadata:{title:"BK's Devlog",subtitle:"I'm front-end web developer, former brand marketer, interested in business-oriented and scalable development. Also, passionate marathoner.",copyright:"powerd by Gatsby, theme by lumen",menu:[{label:"Home",path:"/"},{label:"CS",path:"/categories/cs/"},{label:"JavaScript",path:"/categories/java-script/"},{label:"TypeScript",path:"/categories/type-script/"},{label:"Functional",path:"/categories/functional/"},{label:"Algorithm",path:"/categories/algorithm/"},{label:"React",path:"/categories/react/"},{label:"ETC",path:"/categories/etc/"}],author:{name:"BK",email:"beom911@gmail.com",instagram:"kim.andrea.by",linkedin:"beomyeon-kim-a9b453128",github:"beomyeonandrewkim",rss:"/rss.xml",facebook:"beom911"}}},allMarkdownRemark:{edges:[{node:{fields:{slug:"/posts/TypeScript/type-name",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 35, 47, 47 - 타입 이름",date:"2022-04-03T09:15:03.284Z",category:"TypeScript",description:"코드의 구석 구석까지 타입 안정성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 합니다."}}},{node:{fields:{slug:"/posts/TypeScript/concrete-correct-type",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 33, 34 - 정확하고 구체적인 타입",date:"2022-03-13T09:15:03.284Z",category:"TypeScript",description:'"문자열을 남발하여 선언된" 코드를 피합시다. 모든 문자열을 할당할 수 있는 string타입보다는 더 구체적인 타입을 사용하는 것이 좋습니다.'}}},{node:{fields:{slug:"/posts/TypeScript/use-readonly",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 17 - readonly 사용하기",date:"2022-03-06T09:15:03.284Z",category:"TypeScript",description:"만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋음. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지"}}},{node:{fields:{slug:"/posts/TypeScript/index-signature",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 15, 16 - 인덱스 시그니처",date:"2022-02-25T09:15:03.284Z",category:"TypeScript",description:"런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용"}}},{node:{fields:{slug:"/posts/TypeScript/generic-type",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 14 - 타입 연산과 제너릭 사용으로 반복 줄이기",date:"2022-02-13T09:15:03.284Z",category:"TypeScript",description:"타입에 이름을 붙여서 반복을 피해야합니다. extends를 사용해서 인터페이스 필드의 반복을 피해야합니다."}}},{node:{fields:{slug:"/posts/TypeScript/interface-type",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 13 - 타입과 인터페이스의 차이점 알기",date:"2022-02-01T09:15:03.284Z",category:"TypeScript",description:"타입과 인터페이스의 차이점 알기"}}},{node:{fields:{slug:"/posts/TypeScript/typescript-overview",categorySlug:"/categories/type-script/"},frontmatter:{title:"[이펙티브 타입스크립트] 1장 타입스크립트 알아보기",date:"2022-01-18T09:15:03.284Z",category:"TypeScript",description:"타입스크립트는 자바스크립트의 상위집합입니다. 다시 말해서, 모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램입니다. 반대로, 타입스크립트는 별도의 문법을 가지고 있기 때문에 일반적으로 유효한 자바스크립트 프로그램이 아닙니다."}}}]}},pathContext:{tag:"TypeScript"}}}});
//# sourceMappingURL=path---tags-type-script-3630f3a484290499dd40.js.map