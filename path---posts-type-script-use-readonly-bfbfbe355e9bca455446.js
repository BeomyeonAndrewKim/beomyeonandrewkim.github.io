webpackJsonp([22477797443777],{560:function(e,n){e.exports={data:{site:{siteMetadata:{title:"Andrea's Devlog",subtitle:"I'm front-end web developer, former marketer, interested in business-oriented and scalable development. Also, passionate marathoner.",copyright:"powerd by Gatsby, theme by lumen",author:{name:"Andrea",email:"beom911@gmail.com",instagram:"kim.andrea.by",linkedin:"beomyeon-kim-a9b453128",github:"beomyeonandrewkim",rss:"/rss.xml",facebook:"beom911"},disqusShortname:"beomyeonandrewkim",url:"https://beomyeonandrewkim.github.io"}},markdownRemark:{id:"/Users/beomyeonandreakim/Documents/dev/beomyeonandrewkim.github.io/src/pages/articles/2022-03-06_use-readonly/index.md absPath of file >>> MarkdownRemark",html:'<h3>아이템 17 번경 관련된 오류 방지를 위해 readonly 사용하기</h3>\n<ul>\n<li>\n<p>만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋음. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지.</p>\n<ul>\n<li>배열을 예로 들면</li>\n<li>배열의 요소를 읽을 수 있지만, 쓸 수 는 없음</li>\n<li>length를 읽을 수 있지만, 바꿀 수는 없음</li>\n<li>배열을 변경하는 pop을 비롯한 다른 메서들를 호출할 수 없음(concat은 가능, 변경안하기 때문)</li>\n</ul>\n</li>\n<li>\n<p>readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있음</p>\n</li>\n<li>\n<p>const - readonly 차이 이해 ⇒ 속성변경 가능여부</p>\n<h3>Const</h3>\n<ul>\n<li>변수 참조를 위한 것이다.</li>\n<li>변수에 다른 값을 할당할 수 없다.</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">const ex = &#39;123&#39;;\nex = &#39;456&#39; // ⛔️ 변경 불가</code></pre>\n      </div>\n<h3>readonly</h3>\n<ul>\n<li>속성을 위한 것이다.</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">type readonlyA = {\nreadonly barA: string\n};\n\nconst x: readonlyA = {barA: &#39;baz&#39;};\nx.barA = &#39;quux&#39;; // ⛔️ 변경 불가</code></pre>\n      </div>\n<ul>\n<li>위 예제처럼 속성 <code class="language-text">barA</code>는 변경이 불가능하지만 아래 예제처럼<code class="language-text">barB</code>에 할당된 object값은 변경이 가능하다.</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">type readonlyB = {\nreadonly barB: { baz: string }\n};\n\nconst y: readonlyB = {barB: {baz: &#39;quux&#39;}};\ny.barB.baz = &#39;zebranky&#39;; // 👌 변경 가능</code></pre>\n      </div>\n<blockquote>\n<p>barB.baz에 새로운 값이 할당될 수 있는 이유는 readonly가 얕게 동작하는 것과 관련이 있다.barB가 참조 (refer)하고 있는 값 자체는 변경될 수 없지만 얘가 readonly라고 그 안에 있는 속성들이 모두 동일한 접근 제어자를 가지고 있는 것이 아니다.비슷한 예로 배열에 readonly가 존재한다고 배열 자체가 readonly가 되지 않는다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">const dates: readonly Date[] = [new Date()];\ndates.push(new Date()); // ⛔️ .push()가 존재안한다는 오류 발생\ndates[0].setFullYear(2022); //👌 하지만 다른 위치를 참조할 시 변경 이 가능하다.</code></pre>\n      </div>\n<p>이러한 경우는 속성이 아닌 <strong>객체에 사용되는 <code class="language-text">Readonly</code> 제네릭에도 해당</strong>된다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">interface Outer {\n  inner: {\n    x: number;\n  }\n}\nconst o: ReadOnly&lt;Outer&gt; = { inner: { x:0 }};\no.inner = { x: 1 }; // ⛔️ 변경 불가\no.inner.x = 1; // 👌 o.inner.x는 readonly가 아니므로 변경 가능</code></pre>\n      </div>\n</blockquote>\n</li>\n<li>\n<p>readonly 얕게 동작 ⇒ ts-essentials에 DeepReadonly</p>\n</li>\n</ul>\n<p>출처 <a href="https://www.yes24.com/Product/Goods/102124327">이펙티브 타입스크립트</a></p>',fields:{tagSlugs:["/tags/type-script/","/tags/java-script/","/tags/readonly/"]},frontmatter:{title:"[이펙티브 타입스크립트] 아이템 17 - readonly 사용하기",tags:["TypeScript","JavaScript","readonly"],date:"2022-03-06T09:15:03.284Z",description:"만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋음. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지"}}},pathContext:{slug:"/posts/TypeScript/use-readonly"}}}});
//# sourceMappingURL=path---posts-type-script-use-readonly-bfbfbe355e9bca455446.js.map