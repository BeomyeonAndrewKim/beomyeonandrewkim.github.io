webpackJsonp([0xcd2c2810a491],{552:function(n,a){n.exports={data:{site:{siteMetadata:{title:"Andrea's Devlog",subtitle:"I'm front-end web developer, former marketer, interested in Data Visualization and making project alive. Also, passionate hiking lover.",copyright:"powerd by Gatsby, theme by lumen",author:{name:"Andrea",email:"beom911@gmail.com",instagram:"kim.andrea.by",linkedin:"beomyeon-kim-a9b453128",github:"beomyeonandrewkim",rss:"/rss.xml",facebook:"beom911"},disqusShortname:"beomyeonandrewkim",url:"https://beomyeonandrewkim.github.io"}},markdownRemark:{id:"/Users/beomyeonandreakim/Documents/dev/beomyeonandrewkim.github.io/src/pages/articles/2018-08-04_optimizing-performance/index.md absPath of file >>> MarkdownRemark",html:'<p><em>아래글은 <code class="language-text">ko.reactjs.org</code> 공식문서 번역 프로젝트의 일환으로 contribute한 번역글입니다.</em></p>\n<p>내부적으로 React는 UI를 최신화하기 위해 비용이 많이 드는 DOM 작업의 수를 최소화하기 위해 몇 가지 기발한 방법을 활용합니다. 많은 애플리케이션에서 React를 사용하면 성능을 특별히 최적화하기 위해 많은 작업을 수행하지 않고도 빠른 사용자 인터페이스로 이어질 수 있습니다. 그럼에도 불구하고 React 애플리케이션의 속도를 높일 수 있는 몇 가지 방법이 있습니다.</p>\n<h2>프로덕션 빌드를 활용하세요</h2>\n<p>React 앱에서 성능 문제를 겪고 있거나 벤치마크하고 있는 경우, 축소된 프로덕션 빌드를 사용하여 테스트를 수행하고 있는지 확인하세요.</p>\n<p>기본적으로 React에는 유용한 경고가 많이 포함되어 있습니다. 이 경고들은 개발하는데 있어 매우 유용합니다. 그러나 그 경고는 React를 더 크고 느리게 만들기 때문에 앱을 배포할 때 프로덕션 버전을 사용해야합니다.</p>\n<p>빌드 프로세스가 올바르게 설정되었는지 잘 모르는 경우에는 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools for Chrome</a>를 설치하여 확인할 수 있습니다. 프로덕션 모드의 React 기반 사이트에 접속하면 아이콘의 배경이 어두운 색으로 표시됩니다.</p>\n<img src="https://reactjs.org/static/devtools-prod-d0f767f80866431ccdec18f200ca58f1-1e9b4.png" style="max-width:100%" alt="React DevTools on a website with production version of React">\n<p>개발 모드의 React 기반 사이트에 접속하면 아이콘의 배경이 빨간색으로 표시됩니다.</p>\n<img src="https://reactjs.org/static/devtools-dev-e434ce2f7e64f63e597edf03f4465694-1e9b4.png" style="max-width:100%" alt="React DevTools on a website with development version of React">\n<p>앱을 개발할 때는 개발 모드를, 사용자에게 앱을 배포할 때는 프로덕션 모드를 사용해야 합니다.</p>\n<p>아래에서 프로덕션 용도의 앱을 제작할 수 있는 방법을 확인할 수 있습니다.</p>\n<h3>Create React App</h3>\n<p>프로젝트가 Create React App 기반이라면 아래 명령어를 실행하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">npm run build</code></pre>\n      </div>\n<p>명령어를 실행하면 프로젝트의 <code class="language-text">build/</code> 폴더에 애플리케이션의 프로덕션 빌드파일이 만들어집니다.</p>\n<p>프로덕션 환경에 배포하기 전에만 필요하다는 것을 기억하세요. 정상적인 개발 환경에선 <code class="language-text">npm start</code>를 이용하세요.</p>\n<h3>단일 파일 빌드</h3>\n<p>React 및 React DOM의 프로덕션 준비 버전을 단일 파일로 제공합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16/umd/react.production.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@16/umd/react-dom.production.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre>\n      </div>\n<p><code class="language-text">.production.min.js</code>로 끝나는 React 파일만이 프로덕션 환경에 적합합니다.</p>\n<h3>Brunch</h3>\n<p>가장 효율적인 Brunch 프로덕션 빌드를 위해 <a href="https://github.com/brunch/terser-brunch"><code class="language-text">terser-brunch</code></a>를 설치하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text"># npm을 사용한다면\nnpm install --save-dev terser-brunch\n\n# Yarn을 사용한다면\nyarn add --dev terser-brunch</code></pre>\n      </div>\n<p>다음 프로덕션 빌드를 생성하기 위해 <code class="language-text">build</code> 명령어에 <code class="language-text">-p</code> 플래그를 추가합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">brunch build -p</code></pre>\n      </div>\n<p>프로덕션 빌드에 대해서만 이 작업을 수행하면 됩니다. React의 유용한 경고문구를 숨기고 빌드를 훨씬 느리게 만들기 때문에 개발 환경에서 플러그인을 적용하거나 <code class="language-text">-p</code>플래그를 추가하지 마세요.</p>\n<h3>Browserify</h3>\n<p>가장 효율적인 Browserify 프로덕션 빌드를 위해 몇 가지 플러그인을 설치하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text"># npm을 사용하는 경우\nnpm install --save-dev envify terser uglifyify\n\n# Yarn을 사용하는 경우\nyarn add --dev envify terser uglifyify</code></pre>\n      </div>\n<p>프로덕션 빌드를 만들려면, 다음 변환을 추가하세요. <strong>(순서는 중요합니다.)</strong></p>\n<ul>\n<li><a href="https://github.com/hughsk/envify"><code class="language-text">envify</code></a> 변환은 올바른 빌드 환경이 설정되도록 합니다. 또한 전역 (<code class="language-text">-g</code>)으로 변환시킵니다.</li>\n<li><a href="https://github.com/hughsk/uglifyify"><code class="language-text">uglifyify</code></a> 변환은 개발에서만 사용하는 package를 제거합니다. 또한 전역(<code class="language-text">-g</code>)으로 변환시킵니다.</li>\n<li>마지막으로 최종 bundle은 mangling을 위해 <a href="https://github.com/terser-js/terser"><code class="language-text">terser</code></a>로 연결됩니다. (<a href="https://github.com/hughsk/uglifyify#motivationusage">원리</a>)</li>\n</ul>\n<p>예시를 확인하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">browserify ./index.js \\\n  -g [ envify --NODE_ENV production ] \\\n  -g uglifyify \\\n  | terser --compress --mangle &gt; ./bundle.js</code></pre>\n      </div>\n<p>프로덕션 빌드에서만 필요한 작업이라는 점을 기억하세요. 이러한 플러그인은 React의 유용한 경고를 숨기고 빌드를 훨씬 느리게 만들기 때문에 개발 중에는 적용하지 마세요.</p>\n<h3>Rollup</h3>\n<p>가장 효율적인 Rollup 프로덕션 빌드를 위해 몇 가지 플러그인을 설치하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-bash"><code class="language-bash"><span class="token comment"># npm을 사용하는 경우</span>\n<span class="token function">npm</span> <span class="token function">install</span> --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser\n\n<span class="token comment"># Yarn을 사용하는 경우</span>\nyarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser</code></pre>\n      </div>\n<p>프로덕션 빌드를 만들려면, 다음 플러그인을 추가하세요. <strong>(순서는 중요합니다.)</strong></p>\n<ul>\n<li><a href="https://github.com/rollup/rollup-plugin-replace"><code class="language-text">replace</code></a> 플러그인은 올바른 빌드 환경이 설정되도록 해줍니다.</li>\n<li><a href="https://github.com/rollup/rollup-plugin-commonjs"><code class="language-text">commonjs</code></a> 플러그인은 CommonJS를 지원하도록 해줍니다.</li>\n<li><a href="https://github.com/TrySound/rollup-plugin-terser"><code class="language-text">terser</code></a> 플러그인은 최종 bundle을 압축하고 mangle 해줍니다.</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js">plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n  <span class="token comment">// ...</span>\n  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'rollup-plugin-replace\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token string">\'process.env.NODE_ENV\'</span><span class="token punctuation">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">\'production\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'rollup-plugin-commonjs\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'rollup-plugin-terser\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>전체적인 설정 예시는 <a href="https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0">gist</a>를 참고하세요.</p>\n<p>프로덕션 빌드에서만 필요한 작업이라는 점을 기억하세요. React의 유용한 경고를 숨기고 빌드를 훨씬 느리게 만들기 때문에 <code class="language-text">terser</code> 플러그인이나 <code class="language-text">replace</code> 플러그인을 개발 중에 <code class="language-text">&#39;production&#39;</code> 값으로 적용하지 마세요.</p>\n<h3>webpack</h3>\n<blockquote>\n<p><strong>주의</strong></p>\n<p>Create React App을 사용한다면 <a href="#create-react-app">위 설명</a>을 참고하세요.<br>\n이 부분은 webpack을 직접 구성할 경우에만 해당합니다.</p>\n</blockquote>\n<p>Webpack v4 이상에서는 프로덕션 모드에서 기본적으로 코드를 축소합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> TerserPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'terser-webpack-plugin\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  mode<span class="token punctuation">:</span> <span class="token string">\'production\'</span>\n  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">TerserPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* additional options here */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>이 부분에 대해 더 알고 싶다면 <a href="https://webpack.js.org/guides/production/">webpack 문서</a>를 참고하세요.</p>\n<p>production 빌드에서만 필요한 작업이라는 점을 기억하세요. React의 유용한 경고를 숨기고 빌드를 훨씬 느리게 만들기 때문에 <code class="language-text">TerserPlugin</code>을 개발 중에 적용하지 마세요.</p>\n<h2>Chrome Performance 탭으로 컴포넌트 프로파일링</h2>\n<p><strong>개발</strong> 모드에서 지원되는 브라우저의 Performance 탭을 사용하여 어떻게 컴포넌트가 마운트, 업데이트, 그리고 마운트 해제되는지 시각화할 수 있습니다. 예를 들면.</p>\n<center><img src="https://reactjs.org/static/react-perf-chrome-timeline-64d522b74fb585f1abada9801f85fa9d-dcc89.png" style="max-width:100%" alt="React components in Chrome timeline"></center>\n<p>Chrome에서 이 작업을 하려면</p>\n<ol>\n<li>\n<p>일시적으로 <strong>특히 React 개발 도구를 포함해 모든 Chrome 확장 프로그램을 비활성화하세요.</strong> 결과가 크게 왜곡될 수 있습니다!</p>\n</li>\n<li>\n<p>개발 모드에서 애플리케이션을 실행 중인지 확인하세요.</p>\n</li>\n<li>\n<p>Chrome 개발 도구의 <strong><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool">Performance</a></strong> 탭을 열고 <strong>Record</strong>버튼을 클릭하세요.</p>\n</li>\n<li>\n<p>프로파일링할 작업을 진행하세요. 20초 이상 기록하지 마세요. 그렇지 않으면 Chrome이 멈출 수 있습니다.</p>\n</li>\n<li>\n<p>기록을 멈추세요.</p>\n</li>\n<li>\n<p>React 이벤트는 <strong>User Timing</strong> 라벨로 그룹화됩니다.</p>\n</li>\n</ol>\n<p>더 자세한 사례를 보려면 <a href="https://calibreapp.com/blog/2017-11-28-debugging-react/">Ben Schwarz의 글</a>을 확인하세요.</p>\n<p><strong>수치는 상대적이어서 프로덕션 상태에서는 컴포넌트가 더 빠르게 렌더링 될 수 있다는 사실</strong>을 기억하세요. 그래도 관계없는 UI가 실수에 의해 업데이트되는 현상과 UI 업데이트의 깊이와 빈도를 깨닫는 데 도움을 줄 것입니다.</p>\n<p>현재는 Chrome, Edge 그리고 IE만이 이 기능을 지원하는 브라우저지만 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API">User Timing API</a>가 표준으로 사용되기 때문에 더 많은 브라우저가 지원을 추가할 것으로 예상됩니다.</p>\n<h2>Profiler DevTools Profiler로 컴포넌트 프로파일링</h2>\n<p><code class="language-text">react-dom</code> 16.5+와 <code class="language-text">react-native</code> 0.57+는 React DevTools Profiler를 사용하여 개발 모드에서 향상된 프로파일링 기능을 제공합니다.\nProfiler에 대한 내용은 블로그 포스트 <a href="/blog/2018/09/10/introducing-the-react-profiler.html">“Introducing the React Profiler”</a>에서 확인할 수 있습니다.\nProfiler에 대한 영상도 <a href="https://www.youtube.com/watch?v=nySib7ipZdk">YouTube</a>에서 확인 가능합니다.</p>\n<p>아직 React DevTools를 설치하지 않은 경우 다음 링크에서 확인하세요.</p>\n<ul>\n<li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">Chrome Browser Extension</a></li>\n<li><a href="https://addons.mozilla.org/en-GB/firefox/addon/react-devtools/">Firefox Browser Extension</a></li>\n<li><a href="https://www.npmjs.com/package/react-devtools">Standalone Node Package</a></li>\n</ul>\n<blockquote>\n<p>주의</p>\n<p><code class="language-text">react-dom</code>의 프로덕션 프로파일링 bundle은 <code class="language-text">react-dom/profiling</code>으로 이용할 수 있습니다.\nbundle을 사용하는 법에 대한 자세한 내용은 <a href="https://fb.me/react-profiling">fb.me/react-profiling</a>에서 확인하세요.</p>\n</blockquote>\n<h2>긴 목록 가상화하세요</h2>\n<p>애플리케이션에서 긴 목록(수백 또는 수천행)을 렌더링하는 경우 ‘windowing’이라는 기법을 사용하는 것을 추천합니다. 이 기법은 주어진 시간에 목록의 부분 목록만 렌더링하며 컴포넌트를 다시 렌더링하는 데 걸리는 시간과 생성된 DOM 노드의 수를 크게 줄일 수 있습니다.</p>\n<p><a href="https://react-window.now.sh/">react-window</a>와 <a href="https://bvaughn.github.io/react-virtualized/">react-virtualized</a>는 널리 알려진 windowing 라이브러리입니다. 목록, 그리드 및 표 형식 데이터를 표시하기 위한 몇 가지 재사용 가능한 컴포넌트를 제공합니다. 애플리케이션의 특정한 활용 사례에 더 적합한 것을 원한다면 Twitter처럼 자신만의 windowing 컴포넌트를 만들 수 있습니다.</p>\n<h2>재조정을 피하세요</h2>\n<p>React는 렌더링 된 UI의 internal representation을 빌드하고 유지 관리합니다. 여기에는 컴포넌트에서 반환되는 React 엘리먼트가 포함됩니다. representation은 React가 JavaScript 객체에서의 작업보다 느릴 수 있기 때문에 필요에 따라 DOM 노드를 만들고 기존 노드에 접근하지 못하도록 합니다. 때론 “virtual DOM”이라고 불리기도 하지만, React Native에서 같은 방식으로 동작합니다.</p>\n<p>컴포넌트의 prop이나 state가 변경되면 React는 새로 반환된 엘리먼트를 이전에 렌더링된 엘리먼트와 비교해서 실제 DOM 업데이트가 필요한지 여부를 결정합니다. 같지 않을 경우 React는 DOM을 업데이트합니다.</p>\n<p>React DevTools를 활용해 가상 DOM이 리렌더링되는 현상을 시각화할 수 있습니다.</p>\n<ul>\n<li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">Chrome Browser Extension</a></li>\n<li><a href="https://addons.mozilla.org/en-GB/firefox/addon/react-devtools/">Firefox Browser Extension</a></li>\n<li><a href="https://www.npmjs.com/package/react-devtools">Standalone Node Package</a></li>\n</ul>\n<p>개발자 콘솔의 <strong>React</strong> 탭에서 <strong>Highlight Updates</strong> 옵션을 선택하세요.</p>\n<center><img src=".https://reactjs.org/static/devtools-highlight-updates-97eda4825de476af4515435a0c36ca78-a62e3.png" style="max-width:100%; margin-top:10px;" alt="How to enable highlight updates" /></center>\n<p>페이지와 상호 작용하면서 리렌더링된 컴포넌트 주변 색 테두리가 순간적으로 나타나는 것을 볼 수 있습니다. 이렇게 하면 불필요한 리렌더링을 발견할 수 있습니다. 해당 React DevTools의 기능은 <a href="https://blog.logrocket.com/@edelstein">Ben Edelstein</a>의 <a href="https://blog.logrocket.com/make-react-fast-again-part-3-highlighting-component-updates-6119e45e6833">블로그 포스트</a>에서 확인할 수 있습니다.</p>\n<p>아래 예시를 살펴보세요.</p>\n<center><img src="https://reactjs.org/highlight-updates-example-7a42123e91b1b460b1a65605d6ff0d2b.gif" style="max-width:100%; margin-top:20px;" alt="React DevTools Highlight Updates example"></center>\n<p>두 번째 할 일을 입력하면 모든 key 입력 시 첫 번째 할 일이 화면에서 깜박입니다. 이 현상은 React에 의해 input과 함께 다시 렌더링 된다는 것을 의미합니다. 이런 현상을 때론 “wasted” 렌더라고 부릅니다. 첫 번째 할 일의 내용이 변경되지 않았기 때문에 불필요한 렌더링이라는 것을 우리는 알지만 React는 모릅니다.</p>\n<p>React가 변경된 DOM 노드만 업데이트하더라도 리렌더링에는 여전히 다소 시간이 걸립니다. 대부분의 경우 문제가 되지 않지만 속도 저하가 눈에 띄는 경우 다시 렌더링이 시작되기 전에 실행되는 생명주기 함수 <code class="language-text">shouldComponentUpdate</code>로 이 기능을 무시함으로써 속도를 높일 수 있습니다. 이 함수의 기본 implementation은 <code class="language-text">true</code>를 반환하고 React는 업데이트를 진행합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>몇몇 상황에서 컴포넌트를 업데이트할 필요가 없다는 것을 알고 있다면 <code class="language-text">shouldComponentUpdate</code>에서 <code class="language-text">false</code>를 반환해서 컴포넌트와 그 자식 컴포넌트에서 <code class="language-text">render()</code>를 호출하는 것을 포함해서 전체 렌더링 프로세스를 건너뛰게 할 수 있습니다.</p>\n<p>대부분의 경우 <code class="language-text">shouldComponentUpdate()</code>를 직접 작성하는 대신 <a href="/docs/react-api.html#reactpurecomponent"><code class="language-text">React.PureComponent</code></a>에서 상속 받을 수 있습니다. 그것은 현재와 이전의 prop과 state의 얕은 비교로 <code class="language-text">shouldComponentUpdate()</code>를 호출하는 것과 같습니다.</p>\n<h2>shouldComponentUpdate In Action</h2>\n<p>컴포넌트의 하위트리를 살펴보세요. 각 항목에 대해 <code class="language-text">SCU</code>는 <code class="language-text">shouldComponentUpdate</code>가 반환한 것을 나타내며, <code class="language-text">vDOMEq</code>는 React 엘리먼트가 동일한지 여부를 표시합니다. 마지막으로 원의 색은 컴포넌트를 조정해야 하는지 여부를 나타냅니다.</p>\n<figure><img src="https://reactjs.org/static/should-component-update-5ee1bdf4779af06072a17b7a0654f6db-9a3ff.png" style="max-width:100%"></figure>\n<p><code class="language-text">shouldComponentUpdate</code>는 C2에 뿌리를 둔 하위트리에서 <code class="language-text">false</code>를 반환했기 때문에 React는 C2를 렌더링하려고 시도하지 않았으므로 C4 및 C5에서 <code class="language-text">shouldComponentUpdate</code>를 호출할 필요가 없었습니다.</p>\n<p>C1과 C3의 경우 <code class="language-text">shouldComponentUpdate</code>가 <code class="language-text">true</code>를 반환했으므로 React가 트리의 가장 하위에 가서 확인해야 했습니다. C6의 경우 <code class="language-text">shouldComponentUpdate</code>는 <code class="language-text">true</code>를 반환했고 렌더링 된 엘리먼트는 동일하지 않기 때문에 React는 DOM을 업데이트해야 했습니다.</p>\n<p>마지막 흥미로운 경우는 C8입니다. React는 이 컴포넌트를 렌더링 해야 했지만 이전에 렌더링 된 React 엘리먼트와 동일했기 때문에 DOM을 업데이트할 필요가 없었습니다.</p>\n<p>React는 C6에 대해 DOM 변경(mutation)을 수행하면 되는데, 이는 불가피했습니다. C8의 경우 렌더링 된 React 엘리먼트를 비교해서 빠져(bail out)나오고 C2의 하위트리와 C7의 경우 <code class="language-text">shouldComponentUpdate</code>를 구제할 때 엘리먼트를 비교할 필요조차 없었고 <code class="language-text">render</code>도 호출되지 않았습니다.</p>\n<h2>예시</h2>\n<p>컴포넌트가 변경되는 유일한 방법이 <code class="language-text">props.color</code> 또는 <code class="language-text">state.count</code>변수가 변경되는 경우라면 <code class="language-text">shouldComponentUpdate</code>에서 다음을 확인하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">CounterButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>color <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">!==</span> nextState<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>button\n        color<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>color<span class="token punctuation">}</span>\n        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>state <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n      <span class="token operator">></span>\n        Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>이 코드에서 <code class="language-text">shouldComponentUpdate</code>는 <code class="language-text">props.color</code> 또는 <code class="language-text">state.count</code>에 변화가 있는지 확인합니다. 해당 값들이 변경되지 않으면 컴포넌트가 업데이트되지 않습니다. 컴포넌트가 더 복잡해지면 <code class="language-text">props</code>와 <code class="language-text">state</code>의 모든 필드 사이에 “얕은 비교”를 하는 것과 유사한 패턴을 사용해서 컴포넌트가 업데이트되어야만 하는지 여부를 결정할 수 있습니다. 이 패턴은 React가 <code class="language-text">React.PureComponent</code>에서 단순히 상속받아 활용되는 이 로직을 사용하는 데 도움을 줄 만큼 일반적입니다. 따라서 이 코드는 동일한 효과를 얻을 수 있는 더 간단한 방법입니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CounterButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>button\n        color<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>color<span class="token punctuation">}</span>\n        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>state <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n      <span class="token operator">></span>\n        Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>대부분의 경우 <code class="language-text">shouldComponentUpdate</code>를 쓰는 대신 <code class="language-text">React.PureComponent</code>를 사용할 수 있습니다. 얕은 비교만 수행하기 때문에 얕은 비교로는 지나칠 수 있는 방식으로 state나 props가 변화한다면 사용할 수 없습니다.</p>\n<p>이런 부분은 복잡한 데이터 구조인 경우 문제가 될 수 있습니다. 예를 들어 <code class="language-text">listOfWords</code>라는 컴포넌트가 쉼표로 구분된 단어 목록을 렌더링하고 단어를 목록에 추가할 수 있는 버튼을 클릭하도록 해주는 상위의 <code class="language-text">WordAdder</code> 컴포넌트를 사용한다고 가정을 해보겠습니다. 이 코드는 정상적으로 <strong>작동하지 않습니다.</strong></p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ListOfWords</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>words<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\',\'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">WordAdder</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n      words<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">\'marklar\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// This section is bad style and causes a bug</span>\n    <span class="token keyword">const</span> words <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>words<span class="token punctuation">;</span>\n    words<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">\'marklar\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> words<span class="token punctuation">:</span> words <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>ListOfWords words<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>words<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>문제는 <code class="language-text">PureComponent</code>가 <code class="language-text">this.props.words</code>의 이전 값과 새로운 값을 간단하게 비교한다는 점입니다. 이 코드는 <code class="language-text">WordAdder</code>의 <code class="language-text">handleClick</code>메서드에서 <code class="language-text">words</code>배열을 변경시키기 때문에 배열의 실제 단어가 변경되었다 하더라도 <code class="language-text">this.props.words</code>의 이전 값과 새로운 값은 동일하게 비교됩니다. 따라서 <code class="language-text">ListOfWords</code>는 렌더링 되어야 하는 새로운 단어가 있어도 업데이트되지 않습니다.</p>\n<h2>데이터를 변형시키지 않음으로써 얻는 효과</h2>\n<p>이 문제를 피하는 가장 간단한 방법은 props와 state로 사용중인 값의 변경을 피하는 것입니다. 예를 들어 <code class="language-text">handleClick</code>메서드는 <code class="language-text">concat</code>을 사용해서 다시 작성될 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>state <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    words<span class="token punctuation">:</span> state<span class="token punctuation">.</span>words<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'marklar\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>ES6는 이런 동작을 쉽게 만들어주는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread syntax</a>를 배열에서 지원합니다. Create React App을 사용하고 있다면 이 문법은 기본적으로 사용할 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>state <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    words<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>state<span class="token punctuation">.</span>words<span class="token punctuation">,</span> <span class="token string">\'marklar\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>비슷한 방법으로 mutation을 피하기 위해 객체를 변경하는 코드를 다시 쓸 수 있습니다. 예를 들어 <code class="language-text">colormap</code>이란 객체가 있고 <code class="language-text">colormap.right</code>를 <code class="language-text">&#39;blue&#39;</code>로 변경시키는 함수를 만들고 싶다고 가정해봅시다. 그렇다면 아래와 같이 작성할 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateColorMap</span><span class="token punctuation">(</span>colormap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  colormap<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token string">\'blue\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>객체 원본을 변경시키지 않고 작성하려면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a>메서드를 사용하세요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateColorMap</span><span class="token punctuation">(</span>colormap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> colormap<span class="token punctuation">,</span> <span class="token punctuation">{</span> right<span class="token punctuation">:</span> <span class="token string">\'blue\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p><code class="language-text">updateColorMap</code>은 기존 객체를 변경하지않고 새로운 객체를 반환합니다. <code class="language-text">Object.assign</code>은 ES6의 문법이고 폴리필(polyfill)을 필요로합니다.</p>\n<p>객체 또한 변경 없이 손쉽게 업데이트될 수 있도록 <a href="https://github.com/sebmarkbage/ecmascript-rest-spread">object spread properties</a>를 추가하자는 JavaScript 제안이 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateColorMap</span><span class="token punctuation">(</span>colormap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>colormap<span class="token punctuation">,</span> right<span class="token punctuation">:</span> <span class="token string">\'blue\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>Create React App을 사용하고 있다면 <code class="language-text">Object.assign</code>과 object spread 문법은 기본적으로 활용 가능합니다.</p>\n<h2>불변의 데이터 구조 사용</h2>\n<p><a href="https://github.com/facebook/immutable-js">Immutable.js</a>는 이 문제를 해결할 수 있는 또 다른 방법입니다. 구조적 공유(Structural sharing)를 통해 작동되는 지속성과 불변성을 지닌 컬렉션을 제공합니다.</p>\n<ul>\n<li><em>불변성</em>: 일단 생성되면 컬렉션은 다른 시점에서 변경될 수 없습니다.</li>\n<li><em>지속성</em>: 새로운 컬렉션은 이전 컬렉션과 set과 같은 변화로부터 생성될 수 있습니다. 기존의 컬렉션은 새 컬렉션이 만들어지고 나서도 유효합니다.</li>\n<li><em>구조적 공유(Structural Sharing)</em>: 가능한 한 원본의 컬렉션과 동일한 구조를 사용해서 새 컬렉션이 만들어지므로 복사를 최소화해서 성능을 향상시킵니다.</li>\n</ul>\n<p>불변성은 변화를 추적하는 비용을 적게 만듭니다. 변경은 항상 새로운 객체를 생성하므로 객체에 대한 참조가 변경되었는지 여부만 확인하면 됩니다. 예를 들어 일반적인 JavaScript 코드에서는 아래와 같습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token string">\'bar\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>\ny<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">\'baz\'</span><span class="token punctuation">;</span>\nx <span class="token operator">===</span> y<span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>\n      </div>\n<p><code class="language-text">y</code>는 수정되었지만 <code class="language-text">x</code>와 동일한 객체에 대한 참조이기 때문에 <code class="language-text">true</code>를 반환합니다. immutable.js로 비슷한 코드를 작성할 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> SomeRecord <span class="token operator">=</span> Immutable<span class="token punctuation">.</span><span class="token function">Record</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeRecord</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token string">\'bar\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">\'foo\'</span><span class="token punctuation">,</span> <span class="token string">\'baz\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> z <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">\'foo\'</span><span class="token punctuation">,</span> <span class="token string">\'bar\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nx <span class="token operator">===</span> y<span class="token punctuation">;</span> <span class="token comment">// false</span>\nx <span class="token operator">===</span> z<span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>\n      </div>\n<p>이 경우에는 <code class="language-text">x</code>를 변경할 때 새로운 참조가 반환되기 때문에 <code class="language-text">y</code>에 저장된 새로운 값이 저장된 원래 값과 다른지 확인하기 위해 참조가 동일한지 여부를 판단하는 확인하는 코드<code class="language-text">(x===y)</code>를 사용할 수 있습니다.</p>\n<p>불변성을 가지는 데이터를 사용할 수 있도록 하는 두 개의 라이브러리는 <a href="https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>와 <a href="https://github.com/kolodny/immutability-helper">immutability-helper</a>입니다.</p>\n<p>불변성을 가지는 데이터 구조는 객체의 변경을 추적하는 적은 비용의 방법을 제공합니다. 이는 <code class="language-text">shouldComponentUpdate</code>를 적용하는데 필요한 모든 것입니다. 이 방법은 좋은 성능 향상을 제공할 수 있습니다.</p>',
fields:{tagSlugs:["/tags/frontend/","/tags/react/","/tags/performance/"]},frontmatter:{title:"[React 공식문서] Optimizing Performance",tags:["Frontend","React","Performance"],date:"2019-08-04T19:14:03.284Z",description:"아래글은 ko.reactjs.org 공식문서 번역 프로젝트의 일환으로 contribute한 번역글입니다."}}},pathContext:{slug:"/posts/react/optimizing-performance"}}}});
//# sourceMappingURL=path---posts-react-optimizing-performance-17fe5f4355d31ed52b42.js.map